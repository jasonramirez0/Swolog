{"ast":null,"code":"/*!\n* chartjs-plugin-annotation v1.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2021 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Chart, Animations } from 'chart.js';\nimport { distanceBetweenPoints, callback, isFinite, addRoundedRectPath, toTRBLCorners, valueOrDefault, toFont, isArray, toRadians, isObject, clipArea, unclipArea } from 'chart.js/helpers';\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\nfunction updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\nfunction handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(chart, state, event);\n        break;\n      case 'click':\n        handleClickEvents(chart, state, event, options);\n        break;\n    }\n  }\n}\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n  let element;\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n  const previous = state.hovered;\n  state.hovered = element;\n  dispatchMoveEvents(chart, state, {\n    previous,\n    element\n  }, event);\n}\nfunction dispatchMoveEvents(chart, state, elements, event) {\n  const {\n    previous,\n    element\n  } = elements;\n  if (previous && previous !== element) {\n    dispatchEvent(chart, previous.options.leave || state.listeners.leave, previous, event);\n  }\n  if (element && element !== previous) {\n    dispatchEvent(chart, element.options.enter || state.listeners.enter, element, event);\n  }\n}\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, dblclick, element, event);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, click, element, event);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, click, element, event);\n    }\n  }\n}\nfunction dispatchEvent(chart, handler, element, event) {\n  callback(handler, [{\n    chart,\n    element\n  }, event]);\n}\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return elements.filter(element => element.options.display && element.inRange(position.x, position.y)).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const distance = distanceBetweenPoints(position, center);\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1)[0]; // return only the top item\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;\n  }\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      width,\n      height,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.beginPath();\n    addRoundedRectPath(ctx, {\n      x,\n      y,\n      w: width,\n      h: height,\n      // TODO: v2 remove support for cornerRadius\n      radius: clampAll(toTRBLCorners(valueOrDefault(options.cornerRadius, options.borderRadius)), 0, Math.min(width, height) / 2)\n    });\n    ctx.closePath();\n    ctx.fill();\n\n    // If no border, don't draw it\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {\n      top: y,\n      left: x,\n      bottom: y2,\n      right: x2\n    } = chart.chartArea;\n    let min, max;\n    if (!xScale && !yScale) {\n      return {\n        options: {}\n      };\n    }\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  borderRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nconst PI = Math.PI;\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst toPercent = s => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\nfunction isLineInArea(_ref, _ref2) {\n  let {\n    x,\n    y,\n    x2,\n    y2\n  } = _ref;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = _ref2;\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\nfunction limitPointToArea(_ref3, p2, _ref4) {\n  let {\n    x,\n    y\n  } = _ref3;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = _ref4;\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\nclass LineAnnotation extends Element {\n  intersects(x, y) {\n    let epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.001;\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const sqr = v => v * v;\n    const {\n      x: x1,\n      y: y1,\n      x2,\n      y2\n    } = this;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n    let xx, yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * dx;\n      yy = y1 + t * dy;\n    }\n    return sqr(x - xx) + sqr(y - yy) < epsilon;\n  }\n  labelIsVisible(chartArea) {\n    const label = this.options.label;\n    const inside = !chartArea || isLineInArea(this, chartArea);\n    return inside && label && label.enabled && label.content;\n  }\n  isOnLabel(mouseX, mouseY) {\n    const {\n      labelRect\n    } = this;\n    if (!labelRect || !this.labelIsVisible()) {\n      return false;\n    }\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 && y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    // Draw\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible(chartArea)) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {\n      top: y,\n      left: x,\n      bottom: y2,\n      right: x2\n    } = chart.chartArea;\n    let min, max;\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n    const inside = isLineInArea({\n      x,\n      y,\n      x2,\n      y2\n    }, chart.chartArea);\n    return inside ? limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea) : {\n      x,\n      y,\n      x2,\n      y2,\n      width: Math.abs(x2 - x),\n      height: Math.abs(y2 - y)\n    };\n  }\n}\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderWidth: 0,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    width: undefined,\n    height: undefined,\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction calculateAutoRotation(line) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = line;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n  const {\n    borderWidth,\n    xPadding,\n    yPadding,\n    content\n  } = label;\n  const font = toFont(label.font);\n  ctx.font = font.string;\n  const {\n    width,\n    height\n  } = measureLabel(ctx, label, font);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n  ctx.fillStyle = label.backgroundColor;\n  const stroke = setBorderStyle(ctx, label);\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x: -(width / 2),\n    y: -(height / 2),\n    w: width,\n    h: height,\n    // TODO: v2 remove support for cornerRadius\n    radius: clampAll(toTRBLCorners(valueOrDefault(label.cornerRadius, label.borderRadius)), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n  ctx.fillStyle = label.color;\n  if (content instanceof Image) {\n    const x = -(width / 2) + xPadding + borderWidth / 2;\n    const y = -(height / 2) + yPadding + borderWidth / 2;\n    ctx.drawImage(content, x, y, width - 2 * xPadding - borderWidth, height - 2 * yPadding - borderWidth);\n  } else {\n    const labels = isArray(content) ? content : [content];\n    const x = calculateLabelXAlignment(label, width);\n    const y = -(labels.length - 1) * font.lineHeight / 2;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = label.textAlign;\n    labels.forEach((l, i) => ctx.fillText(l, x, y + i * font.lineHeight));\n  }\n}\nfunction setBorderStyle(ctx, options) {\n  if (options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\nfunction calculateLabelXAlignment(label, width) {\n  const {\n    textAlign,\n    xPadding,\n    borderWidth\n  } = label;\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding + borderWidth / 2;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding - borderWidth / 2;\n  }\n  return 0;\n}\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n  return size;\n}\nconst widthCache = new Map();\nfunction measureLabel(ctx, label, font) {\n  const content = label.content;\n  const borderWidth = label.borderWidth;\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding + borderWidth,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding + borderWidth\n    };\n  }\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n    const key = font.string + '-' + text;\n    if (!widthCache.has(key)) {\n      widthCache.set(key, ctx.measureText(text).width);\n    }\n    width = Math.max(width, widthCache.get(key));\n  }\n  width += 2 * label.xPadding + borderWidth;\n  return {\n    width,\n    height: count * font.lineHeight + label.yPadding * 2 + borderWidth\n  };\n}\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {\n    xAdjust,\n    yAdjust,\n    xPadding,\n    yPadding,\n    position\n  } = label;\n  const p1 = {\n    x: line.x,\n    y: line.y\n  };\n  const p2 = {\n    x: line.x2,\n    y: line.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: xPadding\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: yPadding\n  };\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n  if (position === 'start') {\n    t = calculateTAdjust({\n      w: line.x2 - line.x,\n      h: line.y2 - line.y\n    }, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: line.x - line.x2,\n      h: line.y - line.y2\n    }, rotSize, label, space);\n  }\n  return t;\n}\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {\n    xPadding,\n    yPadding\n  } = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + xPadding - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + yPadding - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\nfunction spaceAround(line, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\nclass EllipseAnnotation extends BoxAnnotation {\n  inRange(x, y) {\n    return pointInEllipse({\n      x,\n      y\n    }, this);\n  }\n  draw(ctx) {\n    const {\n      width,\n      height,\n      options\n    } = this;\n    const center = this.getCenterPoint();\n    ctx.save();\n    ctx.translate(center.x, center.y);\n    if (options.rotation) {\n      ctx.rotate(toRadians(options.rotation));\n    }\n    ctx.beginPath();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.ellipse(0, 0, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n}\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  rotation: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nfunction pointInEllipse(p, ellipse) {\n  const {\n    width,\n    height\n  } = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  return Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2) + Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2) <= 1.0;\n}\nclass PointAnnotation extends Element {\n  inRange(x, y) {\n    const {\n      width,\n      options\n    } = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n    if (radius <= 0) {\n      return false;\n    }\n    return Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2) <= Math.pow(radius, 2);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      width,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const {\n      chartArea,\n      scales\n    } = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n}\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nvar version = \"1.1.0\";\nconst chartStates = new Map();\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\nvar annotation = {\n  id: 'annotation',\n  version,\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350,\n    // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      }\n    },\n    label: {\n      drawTime: null\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`\n    }\n  },\n  additionalOptionScopes: ['']\n};\nconst directUpdater = {\n  update: Object.assign\n};\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\nfunction draw(chart, caller) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n  if (isFinite(range.min) && typeof scale.options.min === 'undefined' && typeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n  if (isFinite(range.max) && typeof scale.options.max === 'undefined' && typeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\nexport { annotation as default };","map":{"version":3,"names":["Element","defaults","Chart","Animations","distanceBetweenPoints","callback","isFinite","addRoundedRectPath","toTRBLCorners","valueOrDefault","toFont","isArray","toRadians","isObject","clipArea","unclipArea","clickHooks","moveHooks","hooks","concat","updateListeners","chart","state","options","annotations","listened","moveListened","forEach","hook","listeners","scope","handleEvent","event","type","handleMoveEvents","handleClickEvents","element","getNearestItem","elements","previous","hovered","dispatchMoveEvents","dispatchEvent","leave","enter","elOpts","dblclick","click","clickTimeout","clearTimeout","setTimeout","dblClickSpeed","handler","position","minDistance","Number","POSITIVE_INFINITY","filter","display","inRange","x","y","reduce","nearestItems","center","getCenterPoint","distance","push","sort","a","b","_index","slice","clamp","from","to","Math","min","max","clampAll","obj","key","Object","keys","scaleValue","scale","value","fallback","parse","getPixelForValue","rotated","point","angle","cos","sin","cx","cy","BoxAnnotation","mouseX","mouseY","useFinalPosition","width","height","getProps","draw","ctx","save","lineWidth","borderWidth","strokeStyle","borderColor","fillStyle","backgroundColor","setLineDash","borderDash","lineDashOffset","borderDashOffset","beginPath","w","h","radius","cornerRadius","borderRadius","closePath","fill","stroke","restore","resolveElementProperties","xScale","scales","xScaleID","yScale","yScaleID","top","left","bottom","y2","right","x2","chartArea","xMin","xMax","yMin","yMax","id","adjustScaleRange","undefined","defaultRoutes","PI","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","toPercent","s","endsWith","parseFloat","isLineInArea","_ref","_ref2","limitPointToArea","_ref3","_ref4","limitLineToArea","area","LineAnnotation","intersects","epsilon","arguments","length","sqr","v","x1","y1","dx","dy","lenSq","xx","yy","labelIsVisible","label","inside","enabled","content","isOnLabel","labelRect","rotation","w2","h2","moveTo","lineTo","drawLabel","scaleID","NaN","endValue","isHorizontal","borderCapStyle","borderJoinStyle","drawTime","font","family","lineHeight","size","style","weight","color","xPadding","yPadding","xAdjust","yAdjust","textAlign","calculateAutoRotation","line","atan2","string","measureLabel","rect","calculateLabelPosition","translate","rotate","setBorderStyle","Image","drawImage","labels","calculateLabelXAlignment","textBaseline","l","i","fillText","lineCap","lineJoin","getImageSize","widthCache","Map","lines","count","text","has","set","measureText","get","rotatedSize","calculateT","pt","xCoordinateSizes","padding","yCoordinateSizes","adjustLabelCoordinate","rotSize","space","spaceAround","calculateTAdjust","lineSize","labelSize","lineW","lineH","r","coordinate","labelSizes","halfSize","EllipseAnnotation","pointInEllipse","ellipse","p","xRadius","yRadius","pow","PointAnnotation","arc","xValue","yValue","version","chartStates","annotationTypes","box","describe","_fallback","annotation","afterRegister","register","afterUnregister","unregister","beforeInit","beforeUpdate","args","annotationOptions","afterDataLimits","afterUpdate","updateElements","mode","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","beforeEvent","destroy","delete","_getState","animations","numbers","properties","descriptors","_indexable","_scriptable","prop","includes","_allKeys","opts","additionalOptionScopes","directUpdater","update","assign","resolveAnimations","animOpts","resyncElements","el","elType","resolveAnnotationOptions","setContext","getContext","skip","isNaN","resolver","result","resolveObj","defs","name","optDefs","$context","create","start","add","splice","Array","caller","range","getScaleLimits","changed","suggestedMin","suggestedMax","handleTickRangeOptions","axis","scaleIDOption","NEGATIVE_INFINITY","raw","default"],"sources":["/Users/jasonramirez/Desktop/fitness-app/frontend/node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-annotation v1.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2021 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Chart, Animations } from 'chart.js';\nimport { distanceBetweenPoints, callback, isFinite, addRoundedRectPath, toTRBLCorners, valueOrDefault, toFont, isArray, toRadians, isObject, clipArea, unclipArea } from 'chart.js/helpers';\n\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      handleMoveEvents(chart, state, event);\n      break;\n    case 'click':\n      handleClickEvents(chart, state, event, options);\n      break;\n    }\n  }\n}\n\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n\n  dispatchMoveEvents(chart, state, {previous, element}, event);\n}\n\nfunction dispatchMoveEvents(chart, state, elements, event) {\n  const {previous, element} = elements;\n  if (previous && previous !== element) {\n    dispatchEvent(chart, previous.options.leave || state.listeners.leave, previous, event);\n  }\n  if (element && element !== previous) {\n    dispatchEvent(chart, element.options.enter || state.listeners.enter, element, event);\n  }\n}\n\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, dblclick, element, event);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, click, element, event);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, click, element, event);\n    }\n  }\n}\n\nfunction dispatchEvent(chart, handler, element, event) {\n  callback(handler, [{chart, element}, event]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return elements\n    .filter((element) => element.options.display && element.inRange(position.x, position.y))\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const distance = distanceBetweenPoints(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1)[0]; // return only the top item\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n\n    return mouseX >= x &&\n\t\t\tmouseX <= x + width &&\n\t\t\tmouseY >= y &&\n\t\t\tmouseY <= y + height;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, width, height, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.beginPath();\n    addRoundedRectPath(ctx, {\n      x, y, w: width, h: height,\n      // TODO: v2 remove support for cornerRadius\n      radius: clampAll(toTRBLCorners(valueOrDefault(options.cornerRadius, options.borderRadius)), 0, Math.min(width, height) / 2)\n    });\n    ctx.closePath();\n    ctx.fill();\n\n    // If no border, don't draw it\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (!xScale && !yScale) {\n      return {options: {}};\n    }\n\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  borderRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nconst PI = Math.PI;\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst toPercent = (s) => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\n\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\n  return !(\n    (x < left && x2 < left) ||\n    (x > right && x2 > right) ||\n    (y < top && y2 < top) ||\n    (y > bottom && y2 > bottom)\n  );\n}\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nclass LineAnnotation extends Element {\n  intersects(x, y, epsilon = 0.001) {\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const sqr = v => v * v;\n    const {x: x1, y: y1, x2, y2} = this;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n    let xx, yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * dx;\n      yy = y1 + t * dy;\n    }\n    return (sqr(x - xx) + sqr(y - yy)) < epsilon;\n  }\n\n  labelIsVisible(chartArea) {\n    const label = this.options.label;\n\n    const inside = !chartArea || isLineInArea(this, chartArea);\n    return inside && label && label.enabled && label.content;\n  }\n\n  isOnLabel(mouseX, mouseY) {\n    const {labelRect} = this;\n    if (!labelRect || !this.labelIsVisible()) {\n      return false;\n    }\n\n    const {x, y} = rotated({x: mouseX, y: mouseY}, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 &&\n      y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, options} = this;\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    // Draw\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible(chartArea)) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n    const inside = isLineInArea({x, y, x2, y2}, chart.chartArea);\n    return inside\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderWidth: 0,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    width: undefined,\n    height: undefined,\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction calculateAutoRotation(line) {\n  const {x, y, x2, y2} = line;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n  const {borderWidth, xPadding, yPadding, content} = label;\n  const font = toFont(label.font);\n  ctx.font = font.string;\n\n  const {width, height} = measureLabel(ctx, label, font);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n\n  ctx.fillStyle = label.backgroundColor;\n  const stroke = setBorderStyle(ctx, label);\n\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x: -(width / 2), y: -(height / 2), w: width, h: height,\n    // TODO: v2 remove support for cornerRadius\n    radius: clampAll(toTRBLCorners(valueOrDefault(label.cornerRadius, label.borderRadius)), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n\n  ctx.fillStyle = label.color;\n  if (content instanceof Image) {\n    const x = -(width / 2) + xPadding + borderWidth / 2;\n    const y = -(height / 2) + yPadding + borderWidth / 2;\n    ctx.drawImage(content, x, y, width - (2 * xPadding) - borderWidth, height - (2 * yPadding) - borderWidth);\n  } else {\n    const labels = isArray(content) ? content : [content];\n    const x = calculateLabelXAlignment(label, width);\n    const y = -(labels.length - 1) * font.lineHeight / 2;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = label.textAlign;\n    labels.forEach((l, i) => ctx.fillText(l, x, y + (i * font.lineHeight)));\n  }\n}\n\nfunction setBorderStyle(ctx, options) {\n  if (options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\nfunction calculateLabelXAlignment(label, width) {\n  const {textAlign, xPadding, borderWidth} = label;\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding + borderWidth / 2;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding - borderWidth / 2;\n  }\n  return 0;\n}\n\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n  return size;\n}\n\nconst widthCache = new Map();\nfunction measureLabel(ctx, label, font) {\n  const content = label.content;\n  const borderWidth = label.borderWidth;\n\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding + borderWidth,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding + borderWidth\n    };\n  }\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n    const key = font.string + '-' + text;\n    if (!widthCache.has(key)) {\n      widthCache.set(key, ctx.measureText(text).width);\n    }\n    width = Math.max(width, widthCache.get(key));\n  }\n  width += 2 * label.xPadding + borderWidth;\n\n  return {\n    width,\n    height: count * font.lineHeight + label.yPadding * 2 + borderWidth\n  };\n}\n\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {xAdjust, yAdjust, xPadding, yPadding, position} = label;\n  const p1 = {x: line.x, y: line.y};\n  const p2 = {x: line.x2, y: line.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: xPadding};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: yPadding};\n\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n  if (position === 'start') {\n    t = calculateTAdjust({w: line.x2 - line.x, h: line.y2 - line.y}, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({w: line.x - line.x2, h: line.y - line.y2}, rotSize, label, space);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {xPadding, yPadding} = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + xPadding - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + yPadding - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {x, x2, y, y2} = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nclass EllipseAnnotation extends BoxAnnotation {\n\n  inRange(x, y) {\n    return pointInEllipse({x, y}, this);\n  }\n\n  draw(ctx) {\n    const {width, height, options} = this;\n    const center = this.getCenterPoint();\n\n    ctx.save();\n\n    ctx.translate(center.x, center.y);\n    if (options.rotation) {\n      ctx.rotate(toRadians(options.rotation));\n    }\n\n    ctx.beginPath();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.ellipse(0, 0, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  rotation: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse) {\n  const {width, height} = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n\n  return (Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2)) + (Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2)) <= 1.0;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(x, y) {\n    const {width, options} = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n\n    if (radius <= 0) {\n      return false;\n    }\n\n    return (Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) <= Math.pow(radius, 2);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  draw(ctx) {\n    const {x, y, width, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {chartArea, scales} = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nvar version = \"1.1.0\";\n\nconst chartStates = new Map();\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\n\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350, // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      },\n    },\n    label: {\n      drawTime: null\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`,\n    },\n  },\n\n  additionalOptionScopes: ['']\n};\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nfunction draw(chart, caller) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n  if (isFinite(range.min) &&\n\t\ttypeof scale.options.min === 'undefined' &&\n\t\ttypeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n  if (isFinite(range.max) &&\n\t\ttypeof scale.options.max === 'undefined' &&\n\t\ttypeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n  return {min, max};\n}\n\nexport { annotation as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}